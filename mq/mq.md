# MQ 设计总结思考

## MQ简介

MQ使用场景
+ 错峰流控
+ 广播
+ 解耦

MQ支持的特性:
+ 消息确认
+ 重复消费(场景需求 消费端出现bug，无法消费需要重新消费)
+ 消息堆积（消费能力赶不上生产）
+ 顺序保证 （消费方希望串行消费避免业务问题）
+ 事务
+ 投递方式（exactly once，at least once，at most once）
+ 历史消费
+ 延迟队列
+ 多租户

MQ隐藏支持:
+ 高可用


## MQ的核心原理

MQ主要本质原理，二次调用，一次存储。

调用的难点：
+ 如何做服务发现（可直接配置服务端地址，可dns寻址，通过注册中心获取）
+ 调用方式(rpc, http)
+ 智能路由
+ 负载均衡

存储的难点:
+ 本地存储（leveldb，rocksdb）
+ 共享存储（数据库）
+ 分布式存储

特性的支持:
+ 消息确认
> 应用返回ack，mq进行删除操作（逻辑删除）
+ 重复消费
> 应用返回失败，mq需要支持重复投递（重新加入投放队列 支持投放策略 比如按间隔投递）
+ 消息堆积
> 消息存储
+ 顺序保证
> 通常来说mq不应该支持这种特性（完全可以业务自己保证，通过状态机的方式），就算mq保证顺序投递
> 应用层封装的时候往往是多线程或者协程处理，这样还需要进一步保证顺序
> mq实现需要解决最后一公里问题（怎么才能转发到同一个实例） 
> 方案 标记order的数据通过哈希选择服务端实例，服务端通过排序队列根据哈希值选择消费实例
+ 事务
+ 投递方式
> + mostly once
> > 服务端只投递一次
> + at least once
> > 服务端没收到响应基于超时时间重新加入发送队列
> + exactly once
> > 需要sdk配合，生成一个全局id，推送到消费端后返回ack之前都需要缓存下来这个id，一旦收到同一个id的数据，丢弃
+ 历史消费
> 只做逻辑删除，支持按照日期等条件进行重新推送
+ 延迟队列
> 按照发送时间存储
+ 多租户
> 新增命名空间，一个租户可以有多个命名空间，一个topic属于一个命名空间
> 权限管理

如何做高可用:
服务能高可用往往是无状态，状态本身依赖一些全局存储（数据库，redis），那mq的设计支持高可用
需要考虑两点: 
客户端推送消息到服务端需要无状态，
数据存储需要无状态（可直接利用分布式存储，数据库，paxos协议）

负载均衡:
+ 客户端到服务端
+ 服务端到消费

如何推送:
+ push
  - 服务端主动推送新产生的消息，服务端需要发现订阅的客户端，处理推送可能出现的超时等问题。
+ pull
  - 实现简单，消费方轮询主动获取，服务端不需要处理比较麻烦的推送问题，缺点 可能不及时
+ push+pull
  - 服务端只通知消费有数据到来，消费主动获取
  
扩缩容机制:

扩缩容最大的问题是数据的迁移问题，数据存储是无状态的话，很容易做扩缩容，直接上报到一个master服务通知客户端

负载均衡:

master 收集所有的元数据（各服务的cpu之类的情况，各服务的topic情况），负责通知客户端相关的变化

性能优化:
+ 写优化: 批量写（缓存一批数据在进行写）
+ 读优化: 考虑到大部分消息需要立即推送，
